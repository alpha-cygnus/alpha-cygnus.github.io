// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE

import * as List from "../node_modules/bs-platform/lib/es6/list.js";
import * as Block from "../node_modules/bs-platform/lib/es6/block.js";
import * as Curry from "../node_modules/bs-platform/lib/es6/curry.js";
import * as $$String from "../node_modules/bs-platform/lib/es6/string.js";
import * as Prsr$BlaBla from "./Prsr.bs.js";
import * as Belt_MapString from "../node_modules/bs-platform/lib/es6/belt_MapString.js";
import * as Belt_SetString from "../node_modules/bs-platform/lib/es6/belt_SetString.js";

function lshow(la) {
  switch (la.tag | 0) {
    case 0 : 
        return "App(" + (lshow(la[0]) + (", " + (lshow(la[1]) + ")")));
    case 1 : 
        return "Abs(" + (la[0] + (", " + (lshow(la[1]) + ")")));
    case 2 : 
        return la[0];
    
  }
}

function frees(la) {
  switch (la.tag | 0) {
    case 0 : 
        return Belt_SetString.union(frees(la[0]), frees(la[1]));
    case 1 : 
        return Belt_SetString.remove(frees(la[1]), la[0]);
    case 2 : 
        return Belt_SetString.fromArray(/* array */[la[0]]);
    
  }
}

function nextName(s) {
  return s + "_";
}

function makeUniq(_s, set) {
  while(true) {
    var s = _s;
    var match = Belt_SetString.has(set, s);
    if (match) {
      _s = s + "_";
      continue ;
    } else {
      return s;
    }
  };
}

function subst(la, x, r) {
  switch (la.tag | 0) {
    case 0 : 
        var r$1 = la[1];
        return /* LApp */Block.__(0, [
                  subst(la[0], x, r$1),
                  subst(r$1, x, r$1)
                ]);
    case 1 : 
        var y = la[0];
        var match = y === x;
        if (match) {
          return la;
        } else {
          return /* LAbs */Block.__(1, [
                    makeUniq(y, frees(r)),
                    subst(la[1], x, r)
                  ]);
        }
    case 2 : 
        var match$1 = la[0] === x;
        if (match$1) {
          return r;
        } else {
          return la;
        }
    
  }
}

function betaStep(la) {
  switch (la.tag | 0) {
    case 0 : 
        var l = la[0];
        var exit = 0;
        switch (l.tag | 0) {
          case 1 : 
              return /* Changed */Block.__(1, [subst(l[1], l[0], la[1])]);
          case 0 : 
          case 2 : 
              exit = 1;
              break;
          
        }
        if (exit === 1) {
          var r = la[1];
          var match = betaStep(l);
          if (match.tag) {
            return /* Changed */Block.__(1, [/* LApp */Block.__(0, [
                          match[0],
                          r
                        ])]);
          } else {
            var match$1 = betaStep(r);
            if (match$1.tag) {
              return /* Changed */Block.__(1, [/* LApp */Block.__(0, [
                            match[0],
                            match$1[0]
                          ])]);
            } else {
              return /* Same */Block.__(0, [la]);
            }
          }
        }
        break;
    case 1 : 
        var match$2 = betaStep(la[1]);
        if (match$2.tag) {
          return /* Changed */Block.__(1, [/* LAbs */Block.__(1, [
                        la[0],
                        match$2[0]
                      ])]);
        } else {
          return /* Same */Block.__(0, [la]);
        }
    case 2 : 
        return /* Same */Block.__(0, [la]);
    
  }
}

function etaStep(la) {
  switch (la.tag | 0) {
    case 1 : 
        var match = la[1];
        var x = la[0];
        switch (match.tag | 0) {
          case 0 : 
              var match$1 = match[1];
              var f = match[0];
              switch (match$1.tag | 0) {
                case 0 : 
                case 1 : 
                    return /* Same */Block.__(0, [la]);
                case 2 : 
                    var match$2 = x === match$1[0] && !Belt_SetString.has(frees(f), x);
                    if (match$2) {
                      return /* Changed */Block.__(1, [f]);
                    } else {
                      return /* Same */Block.__(0, [la]);
                    }
                
              }
          case 1 : 
          case 2 : 
              return /* Same */Block.__(0, [la]);
          
        }
    case 0 : 
    case 2 : 
        return /* Same */Block.__(0, [la]);
    
  }
}

function reduce(_la, fs, _max) {
  while(true) {
    var max = _max;
    var la = _la;
    var match = max > 0;
    if (match) {
      var nla = List.fold_left((function (a, sf) {
              if (a.tag) {
                return a;
              } else {
                return Curry._1(sf, a[0]);
              }
            }), /* Same */Block.__(0, [la]), fs);
      if (nla.tag) {
        _max = max - 1 | 0;
        _la = nla[0];
        continue ;
      } else {
        return nla[0];
      }
    } else {
      return la;
    }
  };
}

var Basic = /* module */[
  /* frees */frees,
  /* nextName */nextName,
  /* makeUniq */makeUniq,
  /* subst */subst,
  /* betaStep */betaStep,
  /* etaStep */etaStep,
  /* reduce */reduce
];

function string_of_chars(chars) {
  return $$String.concat("", List.map((function (param) {
                    return $$String.make(1, param);
                  }), chars));
}

var tSPACE = Prsr$BlaBla.eq(/* " " */32);

function tSPACES(param) {
  return Prsr$BlaBla.rep(tSPACE, param);
}

function tTrim(p) {
  return Prsr$BlaBla.Infix[/* <* */4](tSPACES, Prsr$BlaBla.Infix[/* *> */3](p, tSPACES));
}

function tChar(c, t) {
  return tTrim(Prsr$BlaBla.Infix[/* >>! */2](Prsr$BlaBla.Infix[/* >>= */1](Prsr$BlaBla.eq(c), (function (param) {
                        return t;
                      })), "'" + ($$String.make(1, c) + "' expected")));
}

var tOPEN = tChar(/* "(" */40, /* OPEN */3);

var tCLOSE = tChar(/* ")" */41, /* CLOSE */4);

var tDOT = tChar(/* "." */46, /* DOT */2);

var tLAMBDA = tChar(/* "\\" */92, /* LAMBDA */1);

var tLETTER = Prsr$BlaBla.iif((function (c) {
        if (c >= /* "a" */97) {
          return c <= /* "z" */122;
        } else {
          return false;
        }
      }));

var tDIGIT = Prsr$BlaBla.iif((function (c) {
        if (c >= /* "0" */48) {
          return c <= /* "9" */57;
        } else {
          return false;
        }
      }));

var partial_arg = Prsr$BlaBla.Infix[/* <|> */5];

function partial_arg$1(param) {
  return partial_arg(tLETTER, tDIGIT, param);
}

function partial_arg$2(param) {
  return Prsr$BlaBla.rep(partial_arg$1, param);
}

var partial_arg$3 = Prsr$BlaBla.Infix[/* >> */0];

var tVAR = tTrim(Prsr$BlaBla.Infix[/* >>! */2](Prsr$BlaBla.Infix[/* >>= */1]((function (param) {
                return partial_arg$3(tLETTER, partial_arg$2, param);
              }), (function (param) {
                return /* VAR */[string_of_chars(/* :: */[
                              param[0],
                              param[1]
                            ])];
              })), "VAR expected"));

function tEOL(param) {
  return Prsr$BlaBla.eos(/* EOL */0, param);
}

var partial_arg$4 = Prsr$BlaBla.Infix[/* <|> */5];

function partial_arg$5(param) {
  return partial_arg$4(tVAR, tLAMBDA, param);
}

var partial_arg$6 = Prsr$BlaBla.Infix[/* <|> */5];

function partial_arg$7(param) {
  return partial_arg$6(partial_arg$5, tDOT, param);
}

var partial_arg$8 = Prsr$BlaBla.Infix[/* <|> */5];

function partial_arg$9(param) {
  return partial_arg$8(partial_arg$7, tOPEN, param);
}

var partial_arg$10 = Prsr$BlaBla.Infix[/* <|> */5];

function partial_arg$11(param) {
  return partial_arg$10(partial_arg$9, tCLOSE, param);
}

var partial_arg$12 = Prsr$BlaBla.Infix[/* <|> */5];

function tokens(param) {
  return partial_arg$12(partial_arg$11, tEOL, param);
}

var rLAMBDA = Prsr$BlaBla.Infix[/* >>! */2](Prsr$BlaBla.eq(/* LAMBDA */1), "lambda expected");

var rOPEN = Prsr$BlaBla.Infix[/* >>! */2](Prsr$BlaBla.eq(/* OPEN */3), "( expected");

var rCLOSE = Prsr$BlaBla.Infix[/* >>! */2](Prsr$BlaBla.eq(/* CLOSE */4), ") expected");

var rDOT = Prsr$BlaBla.Infix[/* >>! */2](Prsr$BlaBla.eq(/* DOT */2), "dot expected");

var rVAR = Prsr$BlaBla.Infix[/* >>! */2](Prsr$BlaBla.if_opt((function (t) {
            if (typeof t === "number") {
              return undefined;
            } else {
              return t[0];
            }
          })), "VAR expected");

function r_lambda(inp) {
  var m = function (param) {
    return List.fold_right((function (n, r) {
                  return /* LAbs */Block.__(1, [
                            n,
                            r
                          ]);
                }), param[0], param[1]);
  };
  var partial_arg = Prsr$BlaBla.Infix[/* <* */4](rLAMBDA, Prsr$BlaBla.Infix[/* *> */3](Prsr$BlaBla.rep1(rVAR), rDOT));
  var partial_arg$1 = Prsr$BlaBla.Infix[/* >> */0];
  var p = function (param) {
    return partial_arg$1(partial_arg, r_expr, param);
  };
  return Prsr$BlaBla.Infix[/* >>= */1](p, m)(inp);
}

function r_sub(inp) {
  return Prsr$BlaBla.Infix[/* <* */4](rOPEN, Prsr$BlaBla.Infix[/* *> */3](r_expr, rCLOSE))(inp);
}

function r_prim(inp) {
  var partial_arg = Prsr$BlaBla.Infix[/* <|> */5];
  return Prsr$BlaBla.Infix[/* <|> */5]((function (param) {
                return partial_arg(r_sub, r_lambda, param);
              }), r_var, inp);
}

function r_expr(inp) {
  var r = function (acc, la) {
    switch (acc.tag | 0) {
      case 0 : 
      case 1 : 
          return /* LApp */Block.__(0, [
                    acc,
                    la
                  ]);
      case 2 : 
          if (acc[0] === "") {
            return la;
          } else {
            return /* LApp */Block.__(0, [
                      acc,
                      la
                    ]);
          }
      
    }
  };
  var partial_arg = /* LVar */Block.__(2, [""]);
  var m = function (param) {
    return List.fold_left(r, partial_arg, param);
  };
  return Prsr$BlaBla.Infix[/* >>= */1](Prsr$BlaBla.rep1(r_prim), m)(inp);
}

var r_var = Prsr$BlaBla.Infix[/* >>= */1](rVAR, (function (v) {
        return /* LVar */Block.__(2, [v]);
      }));

function show(param) {
  return Prsr$BlaBla.for_res((function (la) {
                return /* Ok */Block.__(0, [lshow(la)]);
              }), param);
}

var Parser = /* module */[
  /* string_of_chars */string_of_chars,
  /* P */0,
  /* tSPACE */tSPACE,
  /* tSPACES */tSPACES,
  /* tTrim */tTrim,
  /* tChar */tChar,
  /* tOPEN */tOPEN,
  /* tCLOSE */tCLOSE,
  /* tDOT */tDOT,
  /* tLAMBDA */tLAMBDA,
  /* tLETTER */tLETTER,
  /* tDIGIT */tDIGIT,
  /* tVAR */tVAR,
  /* tEOL */tEOL,
  /* tokens */tokens,
  /* rLAMBDA */rLAMBDA,
  /* rOPEN */rOPEN,
  /* rCLOSE */rCLOSE,
  /* rDOT */rDOT,
  /* rVAR */rVAR,
  /* r_lambda */r_lambda,
  /* r_sub */r_sub,
  /* r_var */r_var,
  /* r_prim */r_prim,
  /* r_expr */r_expr,
  /* parser */r_expr,
  /* show */show
];

function subst$1(_la, _ctx) {
  while(true) {
    var ctx = _ctx;
    var la = _la;
    switch (la.tag | 0) {
      case 0 : 
          return /* LApp */Block.__(0, [
                    subst$1(la[0], ctx),
                    subst$1(la[1], ctx)
                  ]);
      case 1 : 
          _ctx = Belt_MapString.remove(ctx, la[0]);
          _la = la[1];
          continue ;
      case 2 : 
          var x = la[0];
          var match = Belt_MapString.get(ctx, x);
          if (match !== undefined) {
            return match;
          } else {
            return /* LVar */Block.__(2, [x]);
          }
      
    }
  };
}

function norm1(la, i) {
  switch (la.tag | 0) {
    case 0 : 
        var f = la[0];
        var exit = 0;
        switch (f.tag | 0) {
          case 1 : 
              return /* tuple */[
                      subst$1(f[1], Belt_MapString.set(Belt_MapString.empty, f[0], la[1])),
                      i - 1 | 0
                    ];
          case 0 : 
          case 2 : 
              exit = 1;
              break;
          
        }
        if (exit === 1) {
          var x = la[1];
          var match = norm(f, i);
          var i1 = match[1];
          var match$1 = i1 < i;
          if (match$1) {
            return /* tuple */[
                    /* LApp */Block.__(0, [
                        match[0],
                        x
                      ]),
                    i1
                  ];
          } else {
            var match$2 = norm(x, i);
            return /* tuple */[
                    /* LApp */Block.__(0, [
                        f,
                        match$2[0]
                      ]),
                    match$2[1]
                  ];
          }
        }
        break;
    case 1 : 
    case 2 : 
        return /* tuple */[
                la,
                i
              ];
    
  }
}

function norm(_la, _i) {
  while(true) {
    var i = _i;
    var la = _la;
    var match = i <= 0;
    if (match) {
      return /* tuple */[
              la,
              i
            ];
    } else {
      var match$1 = norm1(la, i);
      _i = match$1[1];
      _la = match$1[0];
      continue ;
    }
  };
}

function beta1(la, ctx, i) {
  var match = i <= 0;
  if (match) {
    return /* tuple */[
            la,
            ctx,
            i
          ];
  } else {
    switch (la.tag | 0) {
      case 0 : 
          var f = la[0];
          var exit = 0;
          switch (f.tag | 0) {
            case 1 : 
                return /* tuple */[
                        f[1],
                        Belt_MapString.set(ctx, f[0], la[1]),
                        i - 1 | 0
                      ];
            case 0 : 
            case 2 : 
                exit = 1;
                break;
            
          }
          if (exit === 1) {
            var match$1 = beta(f, ctx, i);
            var match$2 = beta(la[1], ctx, match$1[2]);
            return /* tuple */[
                    /* LApp */Block.__(0, [
                        match$1[0],
                        match$2[0]
                      ]),
                    ctx,
                    match$2[2]
                  ];
          }
          break;
      case 1 : 
          return /* tuple */[
                  la,
                  ctx,
                  i
                ];
      case 2 : 
          var match$3 = Belt_MapString.get(ctx, la[0]);
          if (match$3 !== undefined) {
            return /* tuple */[
                    match$3,
                    ctx,
                    i - 1 | 0
                  ];
          } else {
            return /* tuple */[
                    la,
                    ctx,
                    i
                  ];
          }
      
    }
  }
}

function beta(_la, _ctx, _i) {
  while(true) {
    var i = _i;
    var ctx = _ctx;
    var la = _la;
    var match = i <= 0;
    if (match) {
      return /* tuple */[
              la,
              ctx,
              i
            ];
    } else {
      var match$1 = beta1(la, ctx, i);
      _i = match$1[2];
      _ctx = match$1[1];
      _la = match$1[0];
      continue ;
    }
  };
}

var Exec = /* module */[
  /* C */0,
  /* subst */subst$1,
  /* norm1 */norm1,
  /* norm */norm,
  /* beta1 */beta1,
  /* beta */beta
];

var BSS = 0;

export {
  BSS ,
  lshow ,
  Basic ,
  Parser ,
  Exec ,
  
}
/* tSPACE Not a pure module */
