// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE

import * as Block from "../node_modules/bs-platform/lib/es6/block.js";
import * as Curry from "../node_modules/bs-platform/lib/es6/curry.js";
import * as Caml_obj from "../node_modules/bs-platform/lib/es6/caml_obj.js";
import * as Err$BlaBla from "./Err.bs.js";
import * as Caml_option from "../node_modules/bs-platform/lib/es6/caml_option.js";
import * as Strm$BlaBla from "./Strm.bs.js";

function err(s) {
  return /* Error */Block.__(1, [Err$BlaBla.make(s)]);
}

function err2(e1, e2) {
  return /* Error */Block.__(1, [Err$BlaBla.concat(e1, e2)]);
}

function for_res(pred, inp) {
  var match = Strm$BlaBla.peek(inp);
  if (match !== undefined) {
    return /* tuple */[
            Curry._1(pred, Caml_option.valFromOption(match)),
            Strm$BlaBla.next(inp)
          ];
  } else {
    var match$1 = Strm$BlaBla.get_err(inp);
    if (match$1 !== undefined) {
      return /* tuple */[
              /* Error */Block.__(1, [match$1]),
              inp
            ];
    } else {
      return /* tuple */[
              /* Error */Block.__(1, [Err$BlaBla.make("unexpected end of input")]),
              inp
            ];
    }
  }
}

function iif(pred) {
  return (function (param) {
      return for_res((function (t) {
                    var match = Curry._1(pred, t);
                    if (match) {
                      return /* Ok */Block.__(0, [t]);
                    } else {
                      return /* Error */Block.__(1, [Err$BlaBla.make("unexpected")]);
                    }
                  }), param);
    });
}

function if_opt(f) {
  return (function (param) {
      return for_res((function (t) {
                    var match = Curry._1(f, t);
                    if (match !== undefined) {
                      return /* Ok */Block.__(0, [Caml_option.valFromOption(match)]);
                    } else {
                      return /* Error */Block.__(1, [Err$BlaBla.make("unexpected")]);
                    }
                  }), param);
    });
}

function eq(t) {
  return iif((function (tt) {
                return Caml_obj.caml_equal(tt, t);
              }));
}

function eos(r, inp) {
  var match = Strm$BlaBla.peek(inp);
  if (match !== undefined) {
    return /* tuple */[
            /* Error */Block.__(1, [Err$BlaBla.make("EOS expected")]),
            inp
          ];
  } else {
    var match$1 = Strm$BlaBla.get_err(inp);
    if (match$1 !== undefined) {
      return /* tuple */[
              /* Error */Block.__(1, [match$1]),
              inp
            ];
    } else {
      return /* tuple */[
              /* Ok */Block.__(0, [r]),
              inp
            ];
    }
  }
}

function $$var(p1, p2, inp) {
  var ok = Curry._1(p1, inp);
  var match = ok[0];
  if (match.tag) {
    var ok$1 = Curry._1(p2, inp);
    var match$1 = ok$1[0];
    if (match$1.tag) {
      return /* tuple */[
              /* Error */Block.__(1, [Err$BlaBla.concat(match[0], match$1[0])]),
              inp
            ];
    } else {
      return ok$1;
    }
  } else {
    return ok;
  }
}

function seq(p1, p2, inp) {
  var match = Curry._1(p1, inp);
  var match$1 = match[0];
  if (match$1.tag) {
    return /* tuple */[
            /* Error */Block.__(1, [match$1[0]]),
            match[1]
          ];
  } else {
    var match$2 = Curry._1(p2, match[1]);
    var match$3 = match$2[0];
    if (match$3.tag) {
      return /* tuple */[
              /* Error */Block.__(1, [match$3[0]]),
              match$2[1]
            ];
    } else {
      return /* tuple */[
              /* Ok */Block.__(0, [/* tuple */[
                    match$1[0],
                    match$3[0]
                  ]]),
              match$2[1]
            ];
    }
  }
}

function map(f, p, inp) {
  var match = Curry._1(p, inp);
  var match$1 = match[0];
  if (match$1.tag) {
    return /* tuple */[
            /* Error */Block.__(1, [match$1[0]]),
            match[1]
          ];
  } else {
    return /* tuple */[
            /* Ok */Block.__(0, [Curry._1(f, match$1[0])]),
            match[1]
          ];
  }
}

function map_e(e, p, inp) {
  var ok = Curry._1(p, inp);
  if (ok[0].tag) {
    return /* tuple */[
            /* Error */Block.__(1, [Err$BlaBla.make(e)]),
            ok[1]
          ];
  } else {
    return ok;
  }
}

function rep(p, inp) {
  var match = Curry._1(p, inp);
  var match$1 = match[0];
  if (match$1.tag) {
    return /* tuple */[
            /* Ok */Block.__(0, [/* [] */0]),
            inp
          ];
  } else {
    var match$2 = rep(p, match[1]);
    var match$3 = match$2[0];
    if (match$3.tag) {
      return /* tuple */[
              /* Error */Block.__(1, [match$3[0]]),
              match$2[1]
            ];
    } else {
      return /* tuple */[
              /* Ok */Block.__(0, [/* :: */[
                    match$1[0],
                    match$3[0]
                  ]]),
              match$2[1]
            ];
    }
  }
}

function opt(p, inp) {
  var match = Curry._1(p, inp);
  var match$1 = match[0];
  if (match$1.tag) {
    return /* tuple */[
            /* Ok */Block.__(0, [undefined]),
            inp
          ];
  } else {
    return /* tuple */[
            /* Ok */Block.__(0, [Caml_option.some(match$1[0])]),
            match[1]
          ];
  }
}

function $great$great$eq(p, f) {
  return (function (param) {
      return map(f, p, param);
    });
}

function $great$great$bang(p, e) {
  return (function (param) {
      return map_e(e, p, param);
    });
}

function $star$great(p1, p2) {
  return (function (param) {
      return map((function (prim) {
                    return prim[0];
                  }), (function (param) {
                    return seq(p1, p2, param);
                  }), param);
    });
}

function $less$star(p1, p2) {
  return (function (param) {
      return map((function (prim) {
                    return prim[1];
                  }), (function (param) {
                    return seq(p1, p2, param);
                  }), param);
    });
}

var Infix = /* module */[
  /* >> */seq,
  /* >>= */$great$great$eq,
  /* >>! */$great$great$bang,
  /* *> */$star$great,
  /* <* */$less$star,
  /* <|> */$$var
];

function rep1(p) {
  return (function (param) {
      return map((function (param) {
                    return /* :: */[
                            param[0],
                            param[1]
                          ];
                  }), (function (param) {
                    return seq(p, (function (param) {
                                  return rep(p, param);
                                }), param);
                  }), param);
    });
}

var BR = 0;

var parse = Strm$BlaBla.map;

export {
  BR ,
  parse ,
  err ,
  err2 ,
  for_res ,
  iif ,
  if_opt ,
  eq ,
  eos ,
  $$var ,
  seq ,
  map ,
  map_e ,
  rep ,
  opt ,
  Infix ,
  rep1 ,
  
}
/* No side effect */
