// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE

import * as Block from "../node_modules/bs-platform/lib/es6/block.js";
import * as Curry from "../node_modules/bs-platform/lib/es6/curry.js";
import * as Err$BlaBla from "./Err.bs.js";
import * as Caml_option from "../node_modules/bs-platform/lib/es6/caml_option.js";
import * as Caml_string from "../node_modules/bs-platform/lib/es6/caml_string.js";

function make(p0, p1) {
  return /* record */[
          /* p0 */p0,
          /* p1 */p1
        ];
}

function show_pos(prim) {
  return String(prim);
}

function show(l) {
  var p1 = l[/* p1 */1];
  var p0 = l[/* p0 */0];
  var match = p0 === p1;
  if (match) {
    return String(p0);
  } else {
    return String(p0) + ("--" + String(p1));
  }
}

function make2(l1, l2) {
  return /* record */[
          /* p0 */l1[/* p0 */0],
          /* p1 */l2[/* p0 */0]
        ];
}

var Loc = /* module */[
  /* make */make,
  /* show_pos */show_pos,
  /* show */show,
  /* make2 */make2
];

function get_state(prim) {
  return prim[0];
}

function get_loc(prim) {
  return prim[1];
}

function make$1(s, l) {
  return /* tuple */[
          s,
          l
        ];
}

function from_string(s) {
  var len = s.length;
  var next = function (s, i) {
    var match = i >= len;
    if (match) {
      return /* tuple */[
              /* End */0,
              /* record */[
                /* p0 */i,
                /* p1 */i
              ]
            ];
    } else {
      return /* tuple */[
              /* Next */Block.__(0, [
                  Caml_string.get(s, i),
                  (function (param) {
                      return next(s, i + 1 | 0);
                    })
                ]),
              /* record */[
                /* p0 */i,
                /* p1 */i + 1 | 0
              ]
            ];
    }
  };
  return next(s, 0);
}

function to_log(_inp) {
  while(true) {
    var inp = _inp;
    var match = inp[0];
    if (typeof match === "number") {
      return /* () */0;
    } else if (match.tag) {
      console.log(Err$BlaBla.show(match[0]), " at position " + show(inp[1]));
      return /* () */0;
    } else {
      console.log(match[0], show(inp[1]));
      _inp = Curry._1(match[1], /* () */0);
      continue ;
    }
  };
}

function to_list(inp) {
  var match = inp[0];
  if (typeof match === "number" || match.tag) {
    return /* [] */0;
  } else {
    return /* :: */[
            match[0],
            to_list(Curry._1(match[1], /* () */0))
          ];
  }
}

function peek(s) {
  var match = s[0];
  if (typeof match === "number" || match.tag) {
    return undefined;
  } else {
    return Caml_option.some(match[0]);
  }
}

function next(s) {
  var match = s[0];
  if (typeof match === "number" || match.tag) {
    return s;
  } else {
    return Curry._1(match[1], /* () */0);
  }
}

function get_err(s) {
  var match = s[0];
  if (typeof match === "number" || !match.tag) {
    return undefined;
  } else {
    return match[0];
  }
}

function map(p, inp) {
  var match = inp[0];
  if (typeof match === "number") {
    return /* tuple */[
            /* End */0,
            inp[1]
          ];
  } else if (match.tag) {
    return /* tuple */[
            /* Err */Block.__(1, [match[0]]),
            inp[1]
          ];
  } else {
    var match$1 = Curry._1(p, inp);
    var match$2 = match$1[0];
    if (match$2.tag) {
      return /* tuple */[
              /* Err */Block.__(1, [match$2[0]]),
              make2(inp[1], match$1[1][1])
            ];
    } else {
      var next = match$1[1];
      return /* tuple */[
              /* Next */Block.__(0, [
                  match$2[0],
                  (function (param) {
                      return map(p, next);
                    })
                ]),
              make2(inp[1], next[1])
            ];
    }
  }
}

var BR = 0;

export {
  Loc ,
  get_state ,
  get_loc ,
  make$1 as make,
  BR ,
  from_string ,
  to_log ,
  to_list ,
  peek ,
  next ,
  get_err ,
  map ,
  
}
/* No side effect */
