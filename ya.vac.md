# Я.вакансии
Список интересных мне вакансий с попытками решения представленных на странице вакансий задач.

## Разработчик интерфейсов
https://yandex.ru/jobs/vacancies/dev/dev_int_yaservices/

> N.B. Пожалуй тут я ближе всего по имеющимся на данный момент скиллам. Но в целом это не идеальная вакансия, ибо я примерно этим уже и щас занимаюсь, хочется чего-то другого, если будет такая возможность.

### 1.
> Необходимо передать на сервер набор параметров, не перезагружая при этом страницу в браузере. Перечислите все возможные способы для этого. Назовите самый кроссбраузерный.

- hidden iframe
- $.ajax *
- XMLHTTPRequest
- WebSockets

### 2.
> Что такое замыкание в JavaScript?

В случае, если функция 1 возвращает функцию 2, тело которой объявлено внутри функции 1 и использует локальные переменные охватывающей функции, то для корректной работы функции 2 используемые ею локальные переменные функции 1 образуют вместе с кодом функции объект с одним методом, который и называется замыканием.

Пример:
```javascript
function f1() {
	var counter = 0;
	return {
		inc: function() {
			return ++counter;
		},
		dec: function() {
			return --counter;
		}
	}
}
```

`f1()` возвращает объект с двумя замыканиями, при этом оба этих замыкания использует общую переменную, замкнутую из внешней функции (`counter`).
```javascript
var {i, d} = f1();

i(); // 1
i(); // 2
d(); // 1
d(); // 0
d(); // -1
```

### 3.
>Что такое bubbling и capturing при обработке событий?

**bubbling** -- это "всплытие" события по иерархии объектов DOM, вызываются все (установенные обычным образом) обработчики события на элементах начиная с самого глубокого уровня. Процесс можно прекратить браузерозависимым образом (либо, при установке через jQuery - через браузеронезависимый метод stopPropagation()).

**capturing** -- это обратный процесс, предшествующий bubbling'у, на этом этапе обработчики событий вызываются начиная с самого внеiнего объекта и далее вниз по иерархии до объекта, который непосредственно сгенерировал событие. Для обработки события на этом этапе необходимо поставить обработчик с помощью addEventListener с третим парамером true.

В старых IE (<9) фазы caturing не было.

### 4.
> Чем отличаются операторы сравнения `"=="` и `"==="`?

- `==` по задумке означает сравнение по содержимому. На самом деле по стандарту провродится довольно сложный и не совсем очевидный алгоритм сравнения, строки/булевы значения приводятся к числам, undefined == null и т.д.
- `===` означает идентичность. Для идентичности необходимо, чтобы а) совпадали типы операндов и б) были равны ссылки для ссылочных типов или значения для литеральных типов (с некоторыми числовыми нюансами, например NaN никогда не === NaN).

### 5.
> Есть сайт, состоящий из одной страницы, нескольких JS-файлов, нескольких CSS-файлов и десятка иконок. Нужно сократить время загрузки до минимума. Какие действия нужно предпринять?

- Слить JS-файлы в единый файл (следить за ; на стыке файлов), минифицировать, иконки слить в один файл и воспользоваться средствами позиционирования background'а в CSS, CSS тоже слить в единый файл и минифицировать. Также часто полезно разместить ссылку на JS в конец `<body>`.
- Включить поддержку gzip на сервере, отдающем статику.

### 6.
> Расскажите, что такое, по-вашему, идеальный интерфейс.

Проблема в том, что для каждого человека идеальный интерфейс разный, зависит от его опыта и привычек. Часто неэффективный с точки зрения стороннего человека, но привычный интерфейс "лучше".
Идеальный интерфейс в общем случае незаметен для пользователя, он не стоит на пути и не отвлекает на себя внимание (если речь об интерфейса сайтов, выполняющих не только эстетическую функцию).
Интерфейс должен следовать привычкам пользователя, другое дело, что эти привычки иногда можно заново сформировать, но это процесс тяжёлый и не всегда успешный.

### 7.
> Приведите примеры вашего кода. Это могут быть:
ссылка на открытый репозиторий, например GitHub;
ссылка на сам проект (укажите, какую его часть вы написали);
несколько файлов с кодом (укажите, частью какого проекта он является).

https://github.com/alpha-cygnus/

-----------------------------
## Разработчик на Node.js
https://yandex.ru/jobs/vacancies/dev/int_dev_market/

> N.B. Здесь я слегка выбиваюсь из требований в том, что собственно node.js я не изучал подробно. Но на написание сервера из п.4 понадобилось несколько часов, чтобы прочесть документацию по ноде, так что в принципе это вроде не особо сложно.

### 1.
См. пред. вакансию

### 2.
> Мы уделяем большое внимание производительности наших приложений. Нередко случается, что отдельно взятая функция (например, обработчик события) работает достаточно долго, а вызывается часто, что сильно ухудшает отзывчивость интерфейса. 
> Предложите общее решение, позволяющее вызывать любую функцию не чаще N раз в секунду, даже если её вызов происходит чаще.
```javascript
// сделать обёртку для функции, вызов которой приводит к вызову изначальной функции f не чаще n раз в секунду.
function makeThrottled(n, f) {
	var t = null;
	if (!(n > 0)) n = 1;
	var delay = 1000/n;
	if (delay < 4) delay = 4;
	return function() {
		if (t) return;
		t = setTimeout(function() {
			t = null;
		}, delay);
		f.apply(this, arguments);
	}
}
```

### 3.
> Напишите функцию, которая из произвольного входящего массива выберет все комбинации чисел, сумма которых будет равняться 10.
``` javascript
function find10s(a) {
	var res = [];
	function f10(c, cs, i0) {
		if (cs === 10) res.push(c);
		for (var i = i0; i < a.length; i++) {
			f10(c.concat([a[i]]), cs + a[i], i + 1);
		}
	}
	f10([], 0, 0);	
	return res;
}
```


### 4.

> Реализуйте на Node.js простой сервер раздачи статических файлов по запрошенному URL (например, http://localhost/page.css). При этом не используйте другие библиотеки.


```javascript
const http = require('http');
const fs = require('fs');
const path = require('path');

const cts = {
	html: 'text/html',
	jpg: 'image/jpeg',
	jpeg: 'image/jpeg',
	gif: 'image/gif',
	png: 'image/png',
	svg: 'image/svg+xml',
	js: 'application/javascript',
	css: 'text/css',
	xml: 'text/xml',
};
const fileDir = 'www';


const port = process.argv[2] || 3000;
const hostname = process.argv[3] || 'localhost';

const server = http.createServer(function(req, res) {
	console.log(req.url);
	var file = fileDir + req.url;
	if (file.match(/\/$/)) file += 'index.html';
	fs.access(file, fs.F_OK | fs.R_OK, function(err) {
		if (!err) {
			fs.readFile(file, function(err, data) {
				if (!err) {
					res.statusCode = 200;
					var ext = path.extname(file).toLowerCase().substr(1);
					var ct = cts[ext] || 'text/plain';
					console.log('serving ' + file + ' as ' + ct + ' (' + ext + ')');
					res.setHeader('Content-Type', ct);
					res.end(data);
				} else {
					res.statusCode = 500;
					res.setHeader('Content-Type', 'text/plain');
					res.end('error reading file ' + file + ': ' + err);
				}
			});
		} else {
			res.statusCode = 404;
			res.setHeader('Content-Type', 'text/plain');
			res.end('404: Not found\n');
		}
	});
});

server.listen(port, hostname, function() {
	console.log('Server running at http://' + hostname + ':' + port);
});
```

---------------------
## Java-разработчик в Маркет
https://yandex.ru/jobs/vacancies/dev/dev_java_market/

> N.B. Маркет мне интересен как сервис, которым я сам активно польуюсь, против Java я ничего не имею, но глубоких знаний и опыта в ней нет, хотя я с ней имел дело, конечно.

### 1.
> Пусть N такое число, что `0xff = 0xc0 + N`. Напишите представление числа N в десятичной системе счисления.

63

### 2.
> Какие из следующих стандартных контейнеров позволяют найти в них элемент по его значению за O(log(n))?

-	java.util.Vector<E> 
-	java.util.ArrayList<E> 
-	java.util.LinkedList<E> 
- **java.util.TreeSet<E>**
-	java.util.HashSet<E> 
- **сортированный java.util.Vector<E>**
- **сортированный java.util.ArrayList<E>** 
-	сортированный java.util.LinkedList<E> 

### 3.
> Перечислите все проблемы, которые вы видите в данном коде:
```java
  public abstract class Digest {
      private Map<byte[], byte[]> cache = new HashMap<byte[], byte[]>();
 
      public byte[] digest(byte[] input) {
          byte[] result = cache.get(input);
          if (result == null) {
              synchronized (cache) {
                  result = cache.get(input);
                  if (result == null) {
                      result = doDigest(input);
                      cache.put(input, result);
                  }
              }
          }
          return result;
      }
 
      protected abstract byte[] doDigest(byte[] input);
  }
```

- если предположить, что этот класс служит для вычисления сложных дайджестов последовательностей байт с кэшированием, то не стоит использовать byte[] в качестве ключа кэша, ибо два разных массива байт с одним и тем же содержимым будут иметь один и тот же ключ, но хотя, по смыслу (скорее всего), дайждест у них будет один и тот же. Как вариант: обернуть входной массив в кастомный объект с правильно определёнными методами hashCode и equals(), и уже его использовать в качестве ключа. Чтобы это имело смысл hashCode и equals должны выполняться существенно быстрее вычисления дайджеста, иначе кэширование в таком виде вообще не имеет смысла.
- использование get вне synchronized может привести к непредсказуемому результату, если при этом в другом треде идёт put.
- синхронизация сама по себе может свести на нет выгоды от кэширования.

---------------------------
## Разработчик алгоритмов машинного обучения
https://yandex.ru/jobs/vacancies/dev/machine_learning_algorithms_dev/

> и

## Разработчик-алгоритмист
https://yandex.ru/jobs/vacancies/dev/dev_algorithm/

> мне весьма интересны, но я уже не знаю, насколько у меня гибко сейчас мышление для таких задач, а тестовых заданий там нету...
